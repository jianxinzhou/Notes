# RDB 与 AOF 两种持久化机制的优劣势对比

对于一个企业级的 redis 架构来说，持久化是必不可少的。通常，企业级 redis 的集群架构具有海量数据、高并发以及高可用等特点。

「持久化」主要是用来做灾难恢复（数据恢复）。但是，也可以归类到「高可用」的其中一个环节中。例如，如果 redis 整个挂了，自然 redis 就不可用了，那么要做的事情首先是让 redis 尽快变得可用，即重启 redis，使其继续对外提供服务。但是，如果没有做数据备份，即使 redis 重启了，也是不可用的，因为数据都没了。此时，大概率会发生的事情是：大量的客户端请求过来，所有缓存均无法命中，既然在 redis 中无法命中，那么就会去 mysql 之类的数据源头中去找，一下子 mysql 开始承接高并发，然后 mysql 就挂了。mysql 挂了，更没有办法去找数据恢复到 redis 中（redis 的数据哪里来？当然是 mysql）。

有关缓存雪崩的场景以及相对应的企业级解决方法，在后文会有描述。

所以，如果把 redis 的持久化做好，那么即使 redis 发生故障，也可以通过数据备份来快速进行恢复，一旦恢复，即可对外提供服务。因此，redis 的持久化与高可用是有关系的。

redis 的持久化机制分为 2 种：RDB 与 AOF。

## 1. RDB 与 AOF 两种持久化机制的介绍

+ RDB：对 redis 中的数据进行周期性的持久化
  + 每隔一段时间，对 redis 内存中的数据生成 1 份全量的快照
+ AOF：每条写入命令均作为日志，以 *append-only* 的模式写入日志文件，在 redis 重启时，可以通过回放 AOF 日志中的「写入指令」来重建整个数据集

如果我们想要 redis 仅仅作为纯内存的缓存来用，那么可以禁止所有 RDB 和 AOF 的持久化机制。

通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云。如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。

如果同时使用 RDB 和 AOF 2 种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

## 2. RDB 持久化机制的优点

+ RDB 是通过定时对内存中的数据生成全量快照的方式来进行持久化，因此，RDB 会生成多个数据文件，每个数据文件都代表了某一时刻 redis 中的数据，这种产生多个数据文件的方式非常适合做「冷备」，可以将此类完整的数据文件发送到一些远程的安全存储上去，比如 Amazon 的 S3 云服务或者阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。
  + 注意，AOF 实际上也可以做冷备份。虽然，AOF 只有一个文件，但是我们可以每隔一段时间，去 copy 一份出来即可
  + RDB 做冷备的优势在于：RDB 可以由 redis 去控制固定时长生成快照文件，比较方便；而 AOF，还需要自己写脚本定时去拷贝数据文件，以区分不同时刻的数据。此外，RDB 数据做冷备，提供数据恢复的时候，速度比 AOF 快
+ RDB 对 redis 对外所提供的读写服务的影响非常小，可以让 redis 保持高性能，因为在进行 RDB 持久化时，redis 主进程只需 fork 一个子进程，让子进程执行磁盘 I/O 操作来进行持久化即可
  + RDB 对 redis 的性能影响较小，原因在于，RDB，只有在一定的时候才会将数据写入磁盘中，而 AOF 对于 redis 的每条写指令都是要写文件的，虽然可以快速写入 os cache，但是还是有一定的时间开销，速度肯定比 RDB 略慢
+ 相较 AOF 而言，直接基于 RDB 数据文件来重启和恢复 redis 进程更加快速。
  + AOF，存放的是指令日志，做数据恢复的时候，需要回放和执行所有指令日志，以便恢复出内存中的所有数据
  + RDB，就是 1 份数据文件，恢复的时候，直接加载到内存中即可

综合上述优点，RDB 特别适合做冷备。

## 3. RDB 持久化机制的缺点

+ 如果想要在 reids 故障时，尽可能少的丢数据，那么 RDB 不如 AOF。通常，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。
  + 这个问题是 RDB 最大的缺点，即不适合做第一优先的恢复方案，如果依赖 RDB 做第一优先的恢复方案，会导致丢失的数据比较多
+ RDB 每次 fork 子进程来生成快照数据文件时，如果内存中数据量特别大，由于 fork 的开销，可能会导致对客户端提供的服务暂停数毫秒，有时候甚至数秒

## 4. AOF 持久化机制的优点

+ AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，保证 os cache 中的数据写入磁盘中，因此，即使 redis 进程挂了，最多丢失 1 秒钟的数据
+ AOF 日志文件以 *append-only* 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复（redis 提供了工具）
+ AOF rewrite 操作不会影响客户端的读写，因为在 rewrite log 的时候，后台会有另外一个线程，根据 redis 内存中当前的数据，创建出一份恢复数据所需的最小日志。在创建新日志时，老的日志文件仍然会正常写入。当新的 merge 后的日志文件 ready 的时候，会与老的日志文件进行交换，并删除老的日志文件。
+ AOF 日志文件的命令通过非常可读的方式进行记录，该特性非常适合做灾难性的误删除的紧急恢复
  + 例如，某人不小心用 `flushall` 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么可以立即停掉 redis，将 AOF 日志文件中的最后一条 flushall 命令给删了，然后重启 redis，就可以通过恢复机制，自动恢复所有数据

## 5. AOF 持久化机制的缺点

+ 由于 AOF 记录的是指令日志，因此，对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大
+ AOF 开启后，支持的写 qps 会比 RDB 支持的写 qps 低，原因在于：
  + AOF 对于每一条写指令记日志时均需要写 os cache
  + AOF 一般需要配置成每秒 fsync 一次日志文件到磁盘（当然，每秒一次 fsync，性能还是可以接受的）
  + 注意：如果想要保证数据最多只丢 1 条也是可以的，将 AOF 的 fsync 设置成每写入 1 条数据就 fsync 1 次（前提是，这么做会导致 redis 的 qps 大降）
+ AOF 唯一比较大的缺点是：做数据恢复的时候，会比较慢；还有，在做冷备，定期备份时，不大方便，可能要自己手写复杂的脚本去做（因此，AOF 做冷备不是很合适）

## 6. RDB 和 AOF 到底该如何选择

redis 是支持 2 种持久化机制同时开启的。

+ 不要仅仅使用 RDB，因为这样在 redis 宕机时，会导致丢失很多数据
+ 也不要仅仅使用 AOF，因为会存在 2 个问题：
  + 第一，通过 AOF 做冷备，没有 RDB 做冷备恢复速度快
  + 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制带来的未知 bug
+ 综合使用 AOF 和 RDB 两种持久化机制，
  + 用 AOF 来保证数据不丢失（如果配置为 1 秒 fsync 1 次，那么在 redis 宕机时，最多丢失 1 秒的数据量），作为数据恢复的第一选择; 
  + 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复（从某一个远程的云主机上拷贝一份 RDB 文件回来，进行数据恢复），作为整个 redis 数据可用的最后一道防线 